<html><head><title>CodeNarc Report</title><style type='text/css'>
        .reportInfo {
			font-size: 110%;
		}
		.allPackages {
		    font-weight: bold;
		}
        .packageHeader {
			background: lightblue;
			font-size: 150%;
		    font-weight: bold;
		}
        .fileHeader {
			font-size: 120%;
		    font-weight: bold;
		}
        .tableHeader {
			background: lightblue;
		    font-weight: bold;
		}
		.number {
		    text-align: center;
		}
		.priority1 {
		    color: red;
		    font-weight: bold;
		    text-align: center;
		}
		.priority2 {
		    color: orange;
		    font-weight: bold;
		    text-align: center;
		}
		.priority3 {
		    color: blue;
		    font-weight: bold;
		    text-align: center;
		}
        .priority4 {
            color: gray;
            font-weight: bold;
            text-align: center;
        }
		.ruleName {
		    font-weight: bold;
		}
        .violationInfo {
            margin-bottom: 2px;
            margin-top: 2px;
        }
        .violationInfoPrefix {
            font-size: 55%;
            width: 30px;
            color: darkgray;
        }
		.sourceCode {
		    font-family: Arial, sans-serif;
		    font-size: 80%;
            color: mediumblue;
		}
		.moreInfo {
		    font-style: italic;
            color: black;
		}
        .ruleDescriptions {
            font-size: 85%;
        }
		.version {
			font-size: 75%;
		    color: blue;
            margin-top: 10px;
		}

		table {
		    border: 1px solid gray;
		}
		td, th {
		    border: 1px solid gray;
		    border-bottom: 1px solid aqua;
		    border-right: 1px solid aqua;
		}
		em {
		    font-weight: bold;
		}

</style></head><body><h1>CodeNarc Report</h1><p class='reportInfo'>Report timestamp: Nov 30, 2010 1:33:54 PM</p><h2>Summary by Package</h2><table><tr class='tableHeader'><th>Package</th><th>Total Files</th><th>Files with Violations</th><th>Priority 1</th><th>Priority 2</th><th>Priority 3</th></tr><tr><td class='allPackages'>All Packages</td><td class='number'>6</td><td class='number'>0</td><td class='priority1'>0</td><td class='priority2'>0</td><td class='priority3'>0</td></tr><tr><td>grails-app/controllers/fedreg/metadata</td><td class='number'>2</td><td class='number'>0</td><td class='priority1'>0</td><td class='priority2'>0</td><td class='priority3'>0</td></tr><tr><td>grails-app/controllers/fedreg/wayf</td><td class='number'>1</td><td class='number'>0</td><td class='priority1'>0</td><td class='priority2'>0</td><td class='priority3'>0</td></tr><tr><td>grails-app/services/fedreg/metadata</td><td class='number'>2</td><td class='number'>0</td><td class='priority1'>0</td><td class='priority2'>0</td><td class='priority3'>0</td></tr><tr><td>src/groovy/fedreg/metadata</td><td class='number'>1</td><td class='number'>0</td><td class='priority1'>0</td><td class='priority2'>0</td><td class='priority3'>0</td></tr></table><h2>Rule Descriptions</h2><table border='1'><tr class='tableHeader'><th class='ruleDescriptions'>#</th><th class='ruleDescriptions'>Rule Name</th><th class='ruleDescriptions'>Description</th></tr><tr class='ruleDescriptions'><a name='BigDecimalInstantiation'/><td>1</td><td class='ruleName'>BigDecimalInstantiation</td><td>Checks for calls to the <em>BigDecimal</em> constructors that take a <em>double</em> parameter, which may result in an unexpected <em>BigDecimal</em> value.</td></tr><tr class='ruleDescriptions'><a name='BooleanInstantiation'/><td>2</td><td class='ruleName'>BooleanInstantiation</td><td>Use <em>Boolean.valueOf()</em> for variable values or <em>Boolean.TRUE</em> and <em>Boolean.FALSE</em> for constant values instead of calling the <em>Boolean()</em> constructor directly or calling <em>Boolean.valueOf(true)</em> or <em>Boolean.valueOf(false)</em>.</td></tr><tr class='ruleDescriptions'><a name='BooleanMethodReturnsNull'/><td>3</td><td class='ruleName'>BooleanMethodReturnsNull</td><td>Method with Boolean return type returns explicit null. A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.</td></tr><tr class='ruleDescriptions'><a name='CatchError'/><td>4</td><td class='ruleName'>CatchError</td><td>Catching <em>Error</em> is dangerous; it can catch exceptions such as <em>ThreadDeath</em> and <em>OutOfMemoryError</em>.</td></tr><tr class='ruleDescriptions'><a name='CatchException'/><td>5</td><td class='ruleName'>CatchException</td><td>Catching <em>Exception</em> is often too broad or general. It should usually be restricted to framework or infrastructure code, rather than application code.</td></tr><tr class='ruleDescriptions'><a name='CatchIllegalMonitorStateException'/><td>6</td><td class='ruleName'>CatchIllegalMonitorStateException</td><td>Dubious catching of IllegalMonitorStateException. IllegalMonitorStateException is generally only thrown in case of a design flaw in your code (calling wait or notify on an object you do not hold a lock on).</td></tr><tr class='ruleDescriptions'><a name='CatchNullPointerException'/><td>7</td><td class='ruleName'>CatchNullPointerException</td><td>Catching <em>NullPointerException</em> is never appropriate. It should be avoided in the first place with proper null checking, and it can mask underlying errors.</td></tr><tr class='ruleDescriptions'><a name='CatchRuntimeException'/><td>8</td><td class='ruleName'>CatchRuntimeException</td><td>Catching <em>RuntimeException</em> is often too broad or general. It should usually be restricted to framework or infrastructure code, rather than application code.</td></tr><tr class='ruleDescriptions'><a name='CatchThrowable'/><td>9</td><td class='ruleName'>CatchThrowable</td><td>Catching <em>Throwable</em> is dangerous; it can catch exceptions such as <em>ThreadDeath</em> and <em>OutOfMemoryError</em>.</td></tr><tr class='ruleDescriptions'><a name='CloneableWithoutClone'/><td>10</td><td class='ruleName'>CloneableWithoutClone</td><td>A class that implements <em>java.lang.Cloneable</em> should define a <em>clone()</em> method.</td></tr><tr class='ruleDescriptions'><a name='ConfusingClassNamedException'/><td>11</td><td class='ruleName'>ConfusingClassNamedException</td><td>This class is not derived from another exception, but ends with 'Exception'. This will be confusing to users of this class.</td></tr><tr class='ruleDescriptions'><a name='ConstantIfExpression'/><td>12</td><td class='ruleName'>ConstantIfExpression</td><td>Checks for <em>if</em> statements with a constant value for the if expression, such as <em>true</em>, <em>false</em>, <em>null</em>, or a literal constant value.</td></tr><tr class='ruleDescriptions'><a name='ConstantTernaryExpression'/><td>13</td><td class='ruleName'>ConstantTernaryExpression</td><td>Checks for ternary expressions with a constant value for the boolean expression, such as <em>true</em>, <em>false</em>, <em>null</em>, or a literal constant value.</td></tr><tr class='ruleDescriptions'><a name='DeadCode'/><td>14</td><td class='ruleName'>DeadCode</td><td>Dead code appears after a return statement or an exception is thrown. If code appears after one of these statements then it will never be executed and can be safely deleted.</td></tr><tr class='ruleDescriptions'><a name='DoubleNegative'/><td>15</td><td class='ruleName'>DoubleNegative</td><td>There is no point in using a double negative, it is always positive. For instance <em>!!x</em> can always be simplified to x. And <em>!(!x)</em> can as well.</td></tr><tr class='ruleDescriptions'><a name='DuplicateCaseStatement'/><td>16</td><td class='ruleName'>DuplicateCaseStatement</td><td>Check for duplicate <em>case</em> statements in a <em>switch</em> block, such as two equal integers or strings.</td></tr><tr class='ruleDescriptions'><a name='DuplicateImport'/><td>17</td><td class='ruleName'>DuplicateImport</td><td>Duplicate import statements are unnecessary.</td></tr><tr class='ruleDescriptions'><a name='EmptyCatchBlock'/><td>18</td><td class='ruleName'>EmptyCatchBlock</td><td>In most cases, exceptions should not be caught and ignored (swallowed).</td></tr><tr class='ruleDescriptions'><a name='EmptyElseBlock'/><td>19</td><td class='ruleName'>EmptyElseBlock</td><td>Empty <em>else</em> blocks are confusing and serve no purpose.</td></tr><tr class='ruleDescriptions'><a name='EmptyFinallyBlock'/><td>20</td><td class='ruleName'>EmptyFinallyBlock</td><td>Empty <em>finally</em> blocks are confusing and serve no purpose.</td></tr><tr class='ruleDescriptions'><a name='EmptyForStatement'/><td>21</td><td class='ruleName'>EmptyForStatement</td><td>Empty <em>for</em> statements are confusing and serve no purpose.</td></tr><tr class='ruleDescriptions'><a name='EmptyIfStatement'/><td>22</td><td class='ruleName'>EmptyIfStatement</td><td>Empty <em>if</em> statements are confusing and serve no purpose.</td></tr><tr class='ruleDescriptions'><a name='EmptySwitchStatement'/><td>23</td><td class='ruleName'>EmptySwitchStatement</td><td>Empty <em>switch</em> statements are confusing and serve no purpose.</td></tr><tr class='ruleDescriptions'><a name='EmptySynchronizedStatement'/><td>24</td><td class='ruleName'>EmptySynchronizedStatement</td><td>Empty <em>synchronized</em> statements are confusing and serve no purpose.</td></tr><tr class='ruleDescriptions'><a name='EmptyTryBlock'/><td>25</td><td class='ruleName'>EmptyTryBlock</td><td>Empty <em>try</em> blocks are confusing and serve no purpose.</td></tr><tr class='ruleDescriptions'><a name='EmptyWhileStatement'/><td>26</td><td class='ruleName'>EmptyWhileStatement</td><td>Empty <em>while</em> statements are confusing and serve no purpose.</td></tr><tr class='ruleDescriptions'><a name='EqualsAndHashCode'/><td>27</td><td class='ruleName'>EqualsAndHashCode</td><td>If either the <em>boolean equals(Object)</em> or the <em>int hashCode()</em> methods are overridden within a class, then both must be overridden.</td></tr><tr class='ruleDescriptions'><a name='ExplicitArrayListInstantiation'/><td>28</td><td class='ruleName'>ExplicitArrayListInstantiation</td><td>This rule checks for the explicit instantiation of an <em>ArrayList</em>. In Groovy, it is best to write <em>new ArrayList()</em> as <em>[]<em>, which creates the same object.</td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToAndMethod'/><td>29</td><td class='ruleName'>ExplicitCallToAndMethod</td><td>This rule detects when the <em>and(Object)</em> method is called directly in code instead of using the & operator. A groovier way to express this: <em>a.and(b)</em> is this: <em>a & b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToCompareToMethod'/><td>30</td><td class='ruleName'>ExplicitCallToCompareToMethod</td><td>This rule detects when the <em>compareTo(Object)</em> method is called directly in code instead of using the <=>, >, >=, <, and <= operators. A groovier way to express this: <em>a.compareTo(b)</em> is this: <em>a <=> b</em>, or using the other operators.</td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToDivMethod'/><td>31</td><td class='ruleName'>ExplicitCallToDivMethod</td><td>This rule detects when the <em>div(Object)</em> method is called directly in code instead of using the / operator. A groovier way to express this: <em>a.div(b)</em> is this: <em>a / b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToEqualsMethod'/><td>32</td><td class='ruleName'>ExplicitCallToEqualsMethod</td><td>This rule detects when the <em>equals(Object)</em> method is called directly in code instead of using the == or != operator. A groovier way to express this: <em>a.equals(b)</em> is this: <em>a == b</em> and a groovier way to express : <em>!a.equals(b)</em> is : <em>a != b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToGetAtMethod'/><td>33</td><td class='ruleName'>ExplicitCallToGetAtMethod</td><td>This rule detects when the <em>getAt(Object)</em> method is called directly in code instead of using the [] index operator. A groovier way to express this: <em>a.getAt(b)</em> is this: <em>a[b]</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToLeftShiftMethod'/><td>34</td><td class='ruleName'>ExplicitCallToLeftShiftMethod</td><td>This rule detects when the <em>leftShift(Object)</em> method is called directly in code instead of using the << operator. A groovier way to express this: <em>a.leftShift(b)</em> is this: <em>a << b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToMinusMethod'/><td>35</td><td class='ruleName'>ExplicitCallToMinusMethod</td><td>This rule detects when the <em>minus(Object)</em> method is called directly in code instead of using the - operator. A groovier way to express this: <em>a.minus(b)</em> is this: <em>a - b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToModMethod'/><td>36</td><td class='ruleName'>ExplicitCallToModMethod</td><td>This rule detects when the <em>mod(Object)</em> method is called directly in code instead of using the % operator. A groovier way to express this: <em>a.mod(b)</em> is this: <em>a % b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToMultiplyMethod'/><td>37</td><td class='ruleName'>ExplicitCallToMultiplyMethod</td><td>This rule detects when the <em>minus(Object)</em> method is called directly in code instead of using the * operator. A groovier way to express this: <em>a.multiply(b)</em> is this: <em>a * b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToOrMethod'/><td>38</td><td class='ruleName'>ExplicitCallToOrMethod</td><td>This rule detects when the <em>or(Object)</em> method is called directly in code instead of using the | operator. A groovier way to express this: <em>a.or(b)</em> is this: <em>a | b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToPlusMethod'/><td>39</td><td class='ruleName'>ExplicitCallToPlusMethod</td><td>This rule detects when the <em>plus(Object)</em> method is called directly in code instead of using the + operator. A groovier way to express this: <em>a.plus(b)</em> is this: <em>a + b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToPowerMethod'/><td>40</td><td class='ruleName'>ExplicitCallToPowerMethod</td><td>This rule detects when the <em>power(Object)</em> method is called directly in code instead of using the ** operator. A groovier way to express this: <em>a.power(b)</em> is this: <em>a ** b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToRightShiftMethod'/><td>41</td><td class='ruleName'>ExplicitCallToRightShiftMethod</td><td>This rule detects when the <em>rightShift(Object)</em> method is called directly in code instead of using the >> operator. A groovier way to express this: <em>a.rightShift(b)</em> is this: <em>a >> b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitCallToXorMethod'/><td>42</td><td class='ruleName'>ExplicitCallToXorMethod</td><td>This rule detects when the <em>xor(Object)</em> method is called directly in code instead of using the ^ operator. A groovier way to express this: <em>a.xor(b)</em> is this: <em>a ^ b</em></td></tr><tr class='ruleDescriptions'><a name='ExplicitHashMapInstantiation'/><td>43</td><td class='ruleName'>ExplicitHashMapInstantiation</td><td>This rule checks for the explicit instantiation of a <em>HashMap</em>. In Groovy, it is best to write <em>new HashMap()</em> as <em>[:]</em>, which creates the same object.</td></tr><tr class='ruleDescriptions'><a name='ExplicitHashSetInstantiation'/><td>44</td><td class='ruleName'>ExplicitHashSetInstantiation</td><td>This rule checks for the explicit instantiation of a <em>HashSet</em>. In Groovy, it is best to write <em>new HashSet()</em> as <em>[] as Set</em>, which creates the same object.</td></tr><tr class='ruleDescriptions'><a name='ExplicitLinkedListInstantiation'/><td>45</td><td class='ruleName'>ExplicitLinkedListInstantiation</td><td>This rule checks for the explicit instantiation of a <em>LinkedList</em>. In Groovy, it is best to write <em>new LinkedList()</em> as <em>[] as Queue</em>, which creates the same object.</td></tr><tr class='ruleDescriptions'><a name='ExplicitStackInstantiation'/><td>46</td><td class='ruleName'>ExplicitStackInstantiation</td><td>This rule checks for the explicit instantiation of a <em>Stack</em>. In Groovy, it is best to write <em>new Stack()</em> as <em>[] as Stack</em>, which creates the same object.</td></tr><tr class='ruleDescriptions'><a name='ExplicitTreeSetInstantiation'/><td>47</td><td class='ruleName'>ExplicitTreeSetInstantiation</td><td>This rule checks for the explicit instantiation of a <em>TreeSet</em>. In Groovy, it is best to write <em>new TreeSet()</em> as <em>[] as SortedSet</em>, which creates the same object.</td></tr><tr class='ruleDescriptions'><a name='GStringAsMapKey'/><td>48</td><td class='ruleName'>GStringAsMapKey</td><td>A GString should not be used as a map key since its hashcode is not guaranteed to be stable. Consider calling <em>key.toString()</em>.</td></tr><tr class='ruleDescriptions'><a name='GrailsPublicControllerMethod'/><td>49</td><td class='ruleName'>GrailsPublicControllerMethod</td><td>Checks for <em>public</em> methods on Grails controller classes. Static methods are ignored.</td></tr><tr class='ruleDescriptions'><a name='GrailsServletContextReference'/><td>50</td><td class='ruleName'>GrailsServletContextReference</td><td>Checks for references to the <em>servletContext</em> object from within Grails controller and taglib classes.</td></tr><tr class='ruleDescriptions'><a name='GrailsStatelessService'/><td>51</td><td class='ruleName'>GrailsStatelessService</td><td>Checks for fields on Grails service classes. Grails service classes are singletons, by default, and so they should be reentrant and typically stateless. The <em>ignoreFieldNames</em> property specifies one or more field names that should be ignored. The <em>ignoreFieldTypes</em> property specifies one or more field type names that should be ignored. Both can optionally contain wildcard characters ('*' or '?').</td></tr><tr class='ruleDescriptions'><a name='ImportFromSamePackage'/><td>52</td><td class='ruleName'>ImportFromSamePackage</td><td>An import of a class that is within the same package is unnecessary.</td></tr><tr class='ruleDescriptions'><a name='InvertedIfElse'/><td>53</td><td class='ruleName'>InvertedIfElse</td><td>An inverted if-else statement is one in which there is a single <em>if</em> statement with a single <em>else</em> branch and the boolean test of the if is negated. For instance <em>if (!x) false else true</em>. It is usually clearer to write this as <em>if (x) true else false</em>.</td></tr><tr class='ruleDescriptions'><a name='RemoveAllOnSelf'/><td>54</td><td class='ruleName'>RemoveAllOnSelf</td><td>Don't use <em>removeAll</em> to clear a collection. If you want to remove all elements from a collection c, use c.clear, not c.removeAll(c). Calling <em>c.removeAll(c)</em> to clear a collection is less clear, susceptible to errors from typos, less efficient and for some collections, might throw a <em>ConcurrentModificationException</em>.</td></tr><tr class='ruleDescriptions'><a name='ReturnFromFinallyBlock'/><td>55</td><td class='ruleName'>ReturnFromFinallyBlock</td><td>Returning from a <em>finally</em> block is confusing and can hide the original exception.</td></tr><tr class='ruleDescriptions'><a name='ReturnNullFromCatchBlock'/><td>56</td><td class='ruleName'>ReturnNullFromCatchBlock</td><td>Returning <em>null</em> from a catch block often masks errors and requires the client to handle error codes. In some coding styles this is discouraged.</td></tr><tr class='ruleDescriptions'><a name='ReturnsNullInsteadOfEmptyArray'/><td>57</td><td class='ruleName'>ReturnsNullInsteadOfEmptyArray</td><td>Consider returning a zero length array rather than null. It is often a better design to return a length zero array rather than a null reference to indicate that there are no results (i.e., an empty list of results). This way, no explicit check for null is needed by clients of the method.</td></tr><tr class='ruleDescriptions'><a name='ReturnsNullInsteadOfEmptyCollection'/><td>58</td><td class='ruleName'>ReturnsNullInsteadOfEmptyCollection</td><td>Consider returning a zero length collection rather than null. It is often a better design to return a length zero collection rather than a null reference to indicate that there are no results (i.e., an empty list of results). This way, no explicit check for null is needed by clients of the method.</td></tr><tr class='ruleDescriptions'><a name='SerialVersionUID'/><td>59</td><td class='ruleName'>SerialVersionUID</td><td>A serialVersionUID is normally intended to be used with Serialization. It needs to be of type long, static, and final. Also, it should have a visibility modifier such as public or private. Providing no modifier creates a Property and Groovy generates a getter, which is probably not intended.</td></tr><tr class='ruleDescriptions'><a name='StringInstantiation'/><td>60</td><td class='ruleName'>StringInstantiation</td><td>Use a String literal (e.g., "...") instead of calling the corresponding String constructor (new String("..")) directly.</td></tr><tr class='ruleDescriptions'><a name='ThrowError'/><td>61</td><td class='ruleName'>ThrowError</td><td>Checks for throwing an instance of <em>java.lang.Error</em>.</td></tr><tr class='ruleDescriptions'><a name='ThrowException'/><td>62</td><td class='ruleName'>ThrowException</td><td>Checks for throwing an instance of <em>java.lang.Exception</em>.</td></tr><tr class='ruleDescriptions'><a name='ThrowExceptionFromFinallyBlock'/><td>63</td><td class='ruleName'>ThrowExceptionFromFinallyBlock</td><td>Throwing an exception from a <em>finally</em> block is confusing and can hide the original exception.</td></tr><tr class='ruleDescriptions'><a name='ThrowNullPointerException'/><td>64</td><td class='ruleName'>ThrowNullPointerException</td><td>Checks for throwing an instance of <em>java.lang.NullPointerException</em>.</td></tr><tr class='ruleDescriptions'><a name='ThrowRuntimeException'/><td>65</td><td class='ruleName'>ThrowRuntimeException</td><td>Checks for throwing an instance of <em>java.lang.RuntimeException</em>.</td></tr><tr class='ruleDescriptions'><a name='ThrowThrowable'/><td>66</td><td class='ruleName'>ThrowThrowable</td><td>Checks for throwing an instance of <em>java.lang.Throwable</em>.</td></tr><tr class='ruleDescriptions'><a name='UnnecessaryGroovyImport'/><td>67</td><td class='ruleName'>UnnecessaryGroovyImport</td><td>A Groovy file does not need to include an import for classes from <em>java.lang</em>, <em>java.util</em>, <em>java.io</em>, <em>java.net</em>, <em>groovy.lang</em> and <em>groovy.util</em>, as well as the classes <em>java.math.BigDecimal</em> and <em>java.math.BigInteger</em>.</td></tr><tr class='ruleDescriptions'><a name='UnusedArray'/><td>68</td><td class='ruleName'>UnusedArray</td><td>Checks for array allocations that are not assigned or used, unless it is the last statement within a block.</td></tr><tr class='ruleDescriptions'><a name='UnusedImport'/><td>69</td><td class='ruleName'>UnusedImport</td><td>Imports for a class that is never referenced within the source file is unnecessary.</td></tr><tr class='ruleDescriptions'><a name='UnusedObject'/><td>70</td><td class='ruleName'>UnusedObject</td><td>Checks for object allocations that are not assigned or used, unless it is the last statement within a block</td></tr><tr class='ruleDescriptions'><a name='UnusedPrivateField'/><td>71</td><td class='ruleName'>UnusedPrivateField</td><td>Checks for private fields that are not referenced within the same class.</td></tr><tr class='ruleDescriptions'><a name='UnusedPrivateMethod'/><td>72</td><td class='ruleName'>UnusedPrivateMethod</td><td>Checks for private methods that are not referenced within the same class.</td></tr><tr class='ruleDescriptions'><a name='UnusedVariable'/><td>73</td><td class='ruleName'>UnusedVariable</td><td>Checks for variables that are never referenced.</td></tr></table><p class='version'><a href='http://www.codenarc.org'>CodeNarc v0.11</a></p></body></html>